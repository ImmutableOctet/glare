{
	"remove":
	[
	],

	"persist":
	{
		"+name": "Jump State"
	},

	"exclude":
	[
	],

	"local":
	{
		// Pure local instances.
	},

	"threads":
	{
		"some_thread":
		[
			"print(Pausing `some_thread` immediately)",
			"pause()",

			"print(`some_thread` has unpaused)",
			"print(Declaring `when` condition)",

			"when(NameComponent::name == \"Jump State\")",
				"name(some_embedded_thread)",
				"print(Hello from `when` condition)",
				"print(I'm going to wait until somebody wakes me up)",
				"pause()",
				"print(\"I'm back, but there's nothing else to do\")",
				"print(Press jump and `my_thread_name` should finish)",
				"yield(OnButtonPressed::button|Button::Jump)",
			"end"
		],

		"my_thread_name":
		[
			"print(Press jump)",

			"yield(OnButtonPressed::button|Button::Jump)", // Waits until a condition is met.

			// Because these both refer to `child(New Name)` with no other operation inbetween, we can group this into one meta-type descriptor:
			"child(player_model).NameComponent::name = Something else",
			"child(player_model).TypeComponent::type = EntityType::Player",

			"begin_multi",
				"print(Child name changed from `player_model` to `Something else`)",
				"print(Sleeping for 3 seconds...)",
			"end_multi",

			"sleep(3)",
			"print(Press jump again)",

			"yield(OnButtonPressed::button|Button::Jump)",

			{
				"target": "child(Something else)",

				"NameComponent": "New Name"
			},

			"print(Child is now named `New Name`)",

			"print(\"My name is:\")",
			"NameComponent::name = \"A new name\"",
			"PrintCommand(NameComponent::name)",
			"print(Press HeavyAttack to start other thread)",

			"wait(OnButtonPressed::button == Button::HeavyAttack)",

			"print(\"I'm going to wake `some_thread`, which will have `some_embedded_thread` yield for the 'Jump State' name\")",
			"resume(some_thread)",
			"print(I'm now going to wait for `some_thread` to finish its `when` setup)",

			"yield(OnThreadComplete::thread_id|some_thread)",

			"print(I'm now going to wait for `some_embedded_thread` to pick up on a 'Jump State' name)",

			"yield(OnThreadComplete::thread_id|some_embedded_thread)",

			"print(I'm done)",

			"pause()"
			//"terminate()"
			//"stop()" // same as terminate.
			//"pause()"
			//"resume(\"some_thread_name\")" // "continue" also works here.
			//"step(\"some_thread_name\")" // Executes on instruction on a paused thread.
			//revert() // <-- Need to think about this one; i.e. stepping backward in time.
		]
	},

	"rules":
	[
		/*
		{
			"trigger": "OnAirToGround.entity == self/this",
			"state": "player_common"

			//triggers: []
			//triggers: ["OnAirToGround.entity == self", "OnAirToGround.entity == child(model)"]
			//triggers: [{event: "", conditions: []}]
		},
		*/

		{
			"trigger": "OnButtonPressed|Button::Pause",

			"update":
			{
				"NameComponent": "Jump State"
			}
		},

		{
			"trigger": "OnButtonPressed|Button::FirstPerson",
			"resume_thread": "thread(some_embedded_thread)"
		}
	]
}